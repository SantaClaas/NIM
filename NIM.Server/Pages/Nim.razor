@page "/nim"
@inject NavigationManager navigationManager
@inject GameState gameState
<div class="row justify-content-center">
    <div class="col">
        <h1>Nim game</h1>
        <h2>Current player: @gameState.Game.CurrentPlayer.Name</h2>
    </div>
</div>

<div class="row ">
    <div class="col-8">
        @for (int i = 0; i < gameState.Field.Length; ++i)
        {
            <NIM.Server.Shared.NimRow Count="@gameState.Field[i]" OnTake="Take" CanTake="@CanTake(i)" RowIndex=i />
        }
    </div>
    <div class="col-4">
        <h3>Matches taken</h3>
        @for (int i = 0; i < gameState.Players.Count; ++i)
        {
            <div class="row">
                <div class="col">
                    <h6>@gameState.Players[i].Name :</h6>
                </div>
            </div>
            <div class="row">
                <div class="col" style="height: 5rem">
                    @for (int j = 0; j < gameState.SummaryTakes[gameState.Players[i]]; ++j)
                    {
                        <img src="https://cdn.pixabay.com/photo/2016/10/05/19/08/match-1717377_960_720.png" class="img-fluid" width="50" height="50" />
                    }
                </div>
            </div>
        }
    </div>
</div>

<div class="row justify-content-end">
    <div class="col-auto">
        <button class="btn btn-info" @onclick="@EndTurn" disabled="@(!CanEnd)">End turn</button>
    </div>
</div>
@code {


    bool CanTake(int row)
    {
        int[] futureMove = gameState.CurrentMove.Clone() as int[];
        ++futureMove[row];

        return gameState.Rules.IsMoveValid(new Move(futureMove), gameState.Game.CurrentPlayground);
    }

    void Take(int row)
    {
        --gameState.Field[row];
        ++gameState.CurrentMove[row];
        ++gameState.SummaryTakes[gameState.Game.CurrentPlayer];
        this.StateHasChanged();
    }

    bool CanEnd
    {
        get
        {
            return gameState.Rules.IsMoveValid(new Move(gameState.CurrentMove), gameState.Game.CurrentPlayground);
        }
    }

    protected override void OnInitialized()
    {
        Reset();
    }

    void Reset()
    {
        if (gameState == null || gameState.Game == null)
            navigationManager.NavigateTo("/");

        if (gameState.Game.State == NIM.GameState.GameOver)
        {
            navigationManager.NavigateTo("/");
            return;
        }
        gameState.CurrentMove = new int[gameState.Game.CurrentPlayground.Rows.Count];
        //Array.Copy(gameState.Game.CurrentPlayground.Rows, State);
        gameState.Field = gameState.Game.CurrentPlayground.Rows.ToArray();
        if (!(gameState.Game.CurrentPlayer is Models.Human human))
            EndTurn();
    }

    void EndTurn()
    {
        if (gameState.Game.CurrentPlayer is Models.Human human)
        {
            human.NextMove = gameState.CurrentMove;
        }
        else
        {
            Task.Delay(2000);
        }
        // get move
        gameState.Game.Step();
        // apply move
        gameState.Game.Step();
        // check conditions and if it returns false game is over and navigate to winning page
        if (!gameState.Game.Step())
        {
            navigationManager.NavigateTo("/");
        }
        if (gameState.Game.CurrentPlayer is AiPlayerMinMax)
        {
            gameState.SummaryTakes[gameState.Game.CurrentPlayer] += gameState.Game.LastMove.ChangesPerRow.Sum();
        }
        gameState.CurrentMove = new int[gameState.Game.CurrentPlayground.Rows.Count];
        // choose player
        gameState.Game.Step();

        Reset();
    }

}
